// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {PaymentSplitter} from "./PaymentSplitter.sol";
import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";

/**
 * @title PaymentSplitterFactory
 * @notice Factory for deploying minimal clones of PaymentSplitter
 * @dev Uses OpenZeppelin's Clones library (ERC-1167) for gas-efficient deployment
 */
contract PaymentSplitterFactory {
    using Clones for address;

    /// @notice PaymentSplitter implementation address
    address public immutable implementation;

    /// @notice Track all deployed splitters by user
    mapping(address => address[]) private userSplitters;

    /// @notice All deployed splitters
    address[] public allSplitters;

    event SplitterDeployed(
        address indexed creator,
        address indexed splitter,
        uint256 recipientCount
    );

    constructor() {
        // Deploy the implementation contract
        implementation = address(new PaymentSplitter());
    }

    /**
     * @notice Deploy a new PaymentSplitter clone
     * @param payees Array of recipient addresses
     * @param shares Array of shares (must total 10000 = 100%)
     * @return splitterAddress Address of the deployed PaymentSplitter clone
     */
    function createSplitter(
        address[] calldata payees,
        uint256[] calldata shares
    ) external returns (address splitterAddress) {
        require(payees.length > 0, "No payees");
        require(payees.length == shares.length, "Length mismatch");

        // Validate shares total 10000 (100%)
        uint256 totalShares = 0;
        for (uint256 i = 0; i < shares.length; i++) {
            totalShares += shares[i];
        }
        require(totalShares == 10000, "Shares must total 10000");

        // Deploy minimal clone
        splitterAddress = implementation.clone();

        // Initialize the clone
        PaymentSplitter(payable(splitterAddress)).initialize(payees, shares);

        // Track deployment
        userSplitters[msg.sender].push(splitterAddress);
        allSplitters.push(splitterAddress);

        emit SplitterDeployed(msg.sender, splitterAddress, payees.length);

        return splitterAddress;
    }

    /**
     * @notice Get all splitters created by a user
     */
    function getUserSplitters(address user) external view returns (address[] memory) {
        return userSplitters[user];
    }

    /**
     * @notice Get total number of splitters deployed
     */
    function getSplitterCount() external view returns (uint256) {
        return allSplitters.length;
    }
}
